"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3280],{1143:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});var t=s(5689),a=s(4848),i=s(8453);const r={slug:"bilingual-by-design",title:"Bilingual by Design",authors:["dave"],tags:["v3","i18n","gleam","architecture"]},l=void 0,o={authorsImageUrls:[void 0]},d=[{value:"Two Kinds of Text, Two Different Systems",id:"two-kinds-of-text-two-different-systems",level:2},{value:"What Version 2 Taught Us",id:"what-version-2-taught-us",level:2},{value:"Version 3: App Label Translations",id:"version-3-app-label-translations",level:2},{value:"Catching Problems at Compile and Test Time",id:"catching-problems-at-compile-and-test-time",level:3},{value:"Version 3: Content Translations",id:"version-3-content-translations",level:2},{value:"Language Routing",id:"language-routing",level:2},{value:"Why Two Separate Systems?",id:"why-two-separate-systems",level:2},{value:"What&#39;s Next",id:"whats-next",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Curling IO serves hundreds of clubs across Canada, where English and French aren't optional, they're official languages. A club in Quebec needs a fully French experience. A national organization like Curling Canada needs both. Rails has mature i18n support and Version 2 has been fully bilingual from the start, but after a decade of maintaining around 10,000 YAML translation keys, we've hit the limits of what that approach can catch: missing keys, missing translations, and unused keys that accumulate silently over time."}),"\n",(0,a.jsx)(n.p,{children:"In Version 3, we wanted compile-time guarantees that make those problems impossible. This post covers how we designed the i18n system, why we split it into two layers, and what we changed from Version 2."}),"\n",(0,a.jsx)(n.h2,{id:"two-kinds-of-text-two-different-systems",children:"Two Kinds of Text, Two Different Systems"}),"\n",(0,a.jsx)(n.p,{children:"Every bilingual web application has two fundamentally different kinds of text:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"App labels"}),': static UI strings like "Leagues", "Contact", "Email". These are written by developers and change at deploy time.']}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Content"}),": user-entered data like league names, summaries, and descriptions. These are entered by club managers and may change at any time."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In Version 2, app labels came from Rails i18n YAML files loaded at boot, and content was stored in per-language database columns (",(0,a.jsx)(n.code,{children:"name_en"}),", ",(0,a.jsx)(n.code,{children:"name_fr"}),", ",(0,a.jsx)(n.code,{children:"summary_en"}),", ",(0,a.jsx)(n.code,{children:"summary_fr"}),"). This worked, but had pain points we wanted to address."]}),"\n",(0,a.jsx)(n.h2,{id:"what-version-2-taught-us",children:"What Version 2 Taught Us"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"The YAML files grew unwieldy."})," Over the years, our ",(0,a.jsx)(n.code,{children:"en.yml"})," and ",(0,a.jsx)(n.code,{children:"fr.yml"})," files accumulated thousands of keys each. Finding unused keys was a manual process. Ensuring every English key had a French counterpart required discipline that occasionally slipped, resulting in untranslated UI elements showing up in production as blank strings or key paths like ",(0,a.jsx)(n.code,{children:"en.registrations.confirm_button"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Per-language columns didn't scale."})," The ",(0,a.jsx)(n.code,{children:"leagues"})," table in Version 2 has ",(0,a.jsx)(n.code,{children:"name_en"}),", ",(0,a.jsx)(n.code,{children:"name_fr"}),", ",(0,a.jsx)(n.code,{children:"summary_en"}),", ",(0,a.jsx)(n.code,{children:"summary_fr"}),", ",(0,a.jsx)(n.code,{children:"description_en"}),", ",(0,a.jsx)(n.code,{children:"description_fr"}),", ",(0,a.jsx)(n.code,{children:"post_registration_message_en"}),", ",(0,a.jsx)(n.code,{children:"post_registration_message_fr"}),", ",(0,a.jsx)(n.code,{children:"required_reading_en"}),", ",(0,a.jsx)(n.code,{children:"required_reading_fr"}),". That's 10 columns just for translated text on one table. Every new translatable field requires a migration adding two columns. If we ever added a third language, it would mean another column for every translatable field on every table."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Blank vs. missing was ambiguous."})," When ",(0,a.jsx)(n.code,{children:"name_fr"})," was empty, did the manager intentionally leave it blank, or did they just not get around to translating it? The system couldn't tell the difference."]}),"\n",(0,a.jsx)(n.h2,{id:"version-3-app-label-translations",children:"Version 3: App Label Translations"}),"\n",(0,a.jsx)(n.p,{children:"App labels are compiled directly into the application. No database, no YAML files, no runtime file loading. Just Gleam code."}),"\n",(0,a.jsx)(n.p,{children:"The structure is simple:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"translations/keys.gleam   constants for every key\ntranslations/en.gleam     English values\ntranslations/fr.gleam     French values\ntranslations.gleam        builds the lookup, provides t()\n"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Key constants"})," are ",(0,a.jsx)(n.code,{children:"pub const"})," values in ",(0,a.jsx)(n.code,{children:"keys.gleam"}),". This is extra code we've added specifically to get compile-time correctness. Every key used in a page or language file references these constants, so a misspelled key is a compile error rather than a silent runtime bug:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gleam",children:'pub const leagues = "leagues"\npub const contact = "contact"\npub const email_label = "email_label"\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Notice these are flat, no nesting. In Version 2, Rails i18n keys were nested by namespace (",(0,a.jsx)(n.code,{children:"en.registrations.confirm_button"}),", ",(0,a.jsx)(n.code,{children:"en.leagues.index.title"}),", etc.). In practice, the nesting added complexity without much benefit: keys were harder to grep for, reorganizing namespaces meant touching multiple files, and deeply nested YAML was error-prone to edit. Flat keys are simpler to search, simpler to maintain, and work just as well with thousands of entries."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Language files"})," map those constants to translated values:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gleam",children:'// en.gleam\n#(k.leagues, "Leagues"),\n#(k.contact, "Contact"),\n#(k.email_label, "Email"),\n\n// fr.gleam\n#(k.leagues, "Ligues"),\n#(k.contact, "Contact"),\n#(k.email_label, "Courriel"),\n'})}),"\n",(0,a.jsxs)(n.p,{children:["At startup, ",(0,a.jsx)(n.code,{children:"translations.build()"})," assembles these into a nested dictionary (outer key is language code, inner key is translation key). This dictionary gets stored in the application context and threaded into every request. Lookup is two hash table reads, effectively instant."]}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"In pages"}),", we partial-apply the lookup function for the current language:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gleam",children:'let t = t.t(rc.translations, rc.lang, _)\n\n// Then just call t() with key constants\nelement.text(t(k.leagues))   // "Leagues" or "Ligues"\nelement.text(t(k.contact))  // "Contact" (same in both languages!)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This is clean, type-safe, and impossible to mess up at runtime. If a key is missing from a language file, the UI shows ",(0,a.jsx)(n.code,{children:'"[missing: postal_code_label]"'})," so it's immediately clear something needs to be fixed. Much better than a silent blank."]}),"\n",(0,a.jsx)(n.h3,{id:"catching-problems-at-compile-and-test-time",children:"Catching Problems at Compile and Test Time"}),"\n",(0,a.jsxs)(n.p,{children:["Using constants instead of raw strings means a typo like ",(0,a.jsx)(n.code,{children:"t(k.legues)"})," is a compile error because the constant doesn't exist. That alone eliminates an entire class of bugs we dealt with in Version 2."]}),"\n",(0,a.jsx)(n.p,{children:"We also have a test that verifies every English key has a French counterpart and vice versa:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gleam",children:"pub fn should_have_same_keys_in_en_and_fr_test() {\n  let en_keys = en.all() |> dict.keys() |> set.from_list()\n  let fr_keys = fr.all() |> dict.keys() |> set.from_list()\n  set.difference(en_keys, fr_keys) |> should.equal(set.new())\n  set.difference(fr_keys, en_keys) |> should.equal(set.new())\n}\n"})}),"\n",(0,a.jsx)(n.p,{children:"Adding a key to English without adding it to French fails the test suite. No more discovering untranslated strings in production."}),"\n",(0,a.jsx)(n.p,{children:"We also have a script that checks for keys defined but never actually used in any page or template (dead key detection). Between the compiler, the parity test, and the unused key checker, translation problems are caught long before they reach users."}),"\n",(0,a.jsx)(n.p,{children:"Notice how small the test surface is. Because Gleam's type system handles so much at compile time, our tests focus on validating design decisions and business logic rather than guarding against runtime surprises. In Version 2 with Rails, a lot of test effort goes toward catching things that a type system would prevent: nil values, wrong argument types, missing method calls. In Gleam, the compiler handles all of that, so our translation tests are purely about the logic we actually care about: do all languages have the same keys? Does the fallback behavior work correctly?"}),"\n",(0,a.jsx)(n.h2,{id:"version-3-content-translations",children:"Version 3: Content Translations"}),"\n",(0,a.jsxs)(n.p,{children:["Content translations (the user-entered data) take a different approach. Instead of per-language columns, each translatable table has a single ",(0,a.jsx)(n.code,{children:"translations"})," JSON column:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{"fr": {"name": "Ligue du lundi", "summary": "R\xe9sum\xe9 en fran\xe7ais"}}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The primary language value lives in the regular column (",(0,a.jsx)(n.code,{children:"name"}),", ",(0,a.jsx)(n.code,{children:"summary"}),"). Only secondary language overrides go in the JSON. This means:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Primary language reads are free."})," No JSON parsing needed, just read the column."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"No translations? No overhead."})," The column is ",(0,a.jsx)(n.code,{children:"NULL"}),"."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Adding translatable fields requires zero schema changes."})," Just start putting the field name in the JSON."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Adding a third language is just another key in the JSON."})," No migration needed."]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The resolution logic is straightforward: if the user is viewing in the primary language, return the regular column. If they're viewing in a secondary language, look it up in the JSON. If it's not there, fall back to the primary language value. Every field degrades gracefully. A missing French translation shows the English text rather than nothing."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-gleam",children:'// Parse once per record\nlet parsed = i18n.parse(league.data.translations)\n\n// Resolve each field for the current language\nlet name = i18n.resolve(league.data.name, parsed, lang, primary_lang, "name")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This solves the blank-vs-missing ambiguity from Version 2: if a field isn't in the ",(0,a.jsx)(n.code,{children:"translations"})," JSON, it simply hasn't been translated yet, and the primary language value is shown. No guessing."]}),"\n",(0,a.jsx)(n.h2,{id:"language-routing",children:"Language Routing"}),"\n",(0,a.jsx)(n.p,{children:"Language selection comes from the URL path, not cookies or browser headers. This keeps things deterministic and shareable. A French URL always shows French content:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"/leagues"})," - primary language (no prefix)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"/fr/leagues"})," - French (secondary language prefix)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"/en/leagues"})," - redirects to ",(0,a.jsx)(n.code,{children:"/leagues"})," (primary language never gets a prefix)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The router extracts the language from the first path segment, stores it in the request context, and every page and API handler downstream uses it. Clean, predictable, and great for SEO."}),"\n",(0,a.jsx)(n.h2,{id:"why-two-separate-systems",children:"Why Two Separate Systems?"}),"\n",(0,a.jsx)(n.p,{children:"It might seem simpler to have one translation system for everything. But content and app labels have fundamentally different lifecycles:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{}),(0,a.jsx)(n.th,{children:"App Labels"}),(0,a.jsx)(n.th,{children:"Content"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Who writes it"})}),(0,a.jsx)(n.td,{children:"Developers"}),(0,a.jsx)(n.td,{children:"Club managers"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"When it changes"})}),(0,a.jsx)(n.td,{children:"At deploy time"}),(0,a.jsx)(n.td,{children:"At any time"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Where it lives"})}),(0,a.jsx)(n.td,{children:"Compiled code"}),(0,a.jsx)(n.td,{children:"Database"})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:(0,a.jsx)(n.strong,{children:"Scope"})}),(0,a.jsx)(n.td,{children:"Global (all clubs)"}),(0,a.jsx)(n.td,{children:"Per-record"})]})]})]}),"\n",(0,a.jsx)(n.p,{children:'Storing "Leagues" in the database would add a database read to every page render for no reason. Putting league names in compiled code would make them uneditable. The two-system approach lets each do what it\'s best at.'}),"\n",(0,a.jsx)(n.h2,{id:"whats-next",children:"What's Next"}),"\n",(0,a.jsxs)(n.p,{children:["The i18n foundation is in place. As we build out more features (admin interfaces, registration flows, email notifications) we'll add keys to the app label system and the ",(0,a.jsx)(n.code,{children:"translations"})," JSON column to more tables. The system is designed to scale to thousands of keys without any architectural changes."]}),"\n",(0,a.jsx)(n.p,{children:"Next up: we'll be looking at authentication and the admin interface, which will be the first real test of these systems under more complex UI."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.em,{children:["This is part of an ongoing series documenting the technical decisions behind Curling IO Version 3. Previous post: ",(0,a.jsx)(n.a,{href:"/blog/the-next-version-of-curling-io",children:"The Next Version of Curling IO"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},5689:e=>{e.exports=JSON.parse('{"permalink":"/blog/bilingual-by-design","source":"@site/blog/2026-02-15-bilingual-by-design.md","title":"Bilingual by Design","description":"Curling IO serves hundreds of clubs across Canada, where English and French aren\'t optional, they\'re official languages. A club in Quebec needs a fully French experience. A national organization like Curling Canada needs both. Rails has mature i18n support and Version 2 has been fully bilingual from the start, but after a decade of maintaining around 10,000 YAML translation keys, we\'ve hit the limits of what that approach can catch: missing keys, missing translations, and unused keys that accumulate silently over time.","date":"2026-02-15T00:00:00.000Z","tags":[{"inline":true,"label":"v3","permalink":"/blog/tags/v-3"},{"inline":true,"label":"i18n","permalink":"/blog/tags/i-18-n"},{"inline":true,"label":"gleam","permalink":"/blog/tags/gleam"},{"inline":true,"label":"architecture","permalink":"/blog/tags/architecture"}],"readingTime":7.16,"hasTruncateMarker":true,"authors":[{"name":"Dave Rapin","title":"Founder @ Curling IO","imageURL":"https://avatars.githubusercontent.com/u/1202?v=4","key":"dave","page":null}],"frontMatter":{"slug":"bilingual-by-design","title":"Bilingual by Design","authors":["dave"],"tags":["v3","i18n","gleam","architecture"]},"unlisted":false,"nextItem":{"title":"The Next Version of Curling IO","permalink":"/blog/the-next-version-of-curling-io"}}')},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const a={},i=t.createContext(a);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);