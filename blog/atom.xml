<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://curling.io/blog</id>
    <title>Curling IO Dev Blog</title>
    <updated>2026-02-20T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://curling.io/blog"/>
    <subtitle>Developer insights on building and enhancing Curling IO</subtitle>
    <icon>https://curling.io/img/favicon.ico</icon>
    <rights>Copyright © 2026 Curling IO</rights>
    <entry>
        <title type="html"><![CDATA[Passwordless Auth, Done Right]]></title>
        <id>https://curling.io/blog/passwordless-auth-done-right</id>
        <link href="https://curling.io/blog/passwordless-auth-done-right"/>
        <updated>2026-02-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Curling IO has been passwordless since Version 2. No passwords to remember, no passwords to steal, no password reset flows. You enter your email, we send you a short-lived login code, and you're in. It's been working well for over a decade, and for Version 3 we're keeping the same approach while fixing some rough edges and adding multi-email support.]]></summary>
        <content type="html"><![CDATA[<p>Curling IO has been passwordless since Version 2. No passwords to remember, no passwords to steal, no password reset flows. You enter your email, we send you a short-lived login code, and you're in. It's been working well for over a decade, and for Version 3 we're keeping the same approach while fixing some rough edges and adding multi-email support.</p>
<p>But first, let's talk about why we made this <u><em>controversial decision</em></u> in the first place.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-not-passwords">Why Not Passwords?<a href="https://curling.io/blog/passwordless-auth-done-right#why-not-passwords" class="hash-link" aria-label="Direct link to Why Not Passwords?" title="Direct link to Why Not Passwords?">​</a></h2>
<p>The conventional wisdom is that passwords are the "real" way to authenticate and login links are a shortcut. We think it's the opposite. Passwords are the shortcut, and they create more problems than they solve. We're not alone. Slack, Notion, Medium, and Substack all use passwordless login links as their primary authentication method.</p>
<p><strong>Passwords get reused.</strong> Study after study shows that most people reuse the same password across multiple sites. When any one of those sites gets breached, attackers try those credentials everywhere else. This isn't a theoretical risk. It happens constantly, and it's the number one way accounts get compromised. As an application developer, you can't control what your users do on other sites, but you inherit the risk.</p>
<p><strong>Passwords get phished.</strong> A convincing fake login page can harvest credentials at scale. Login links are inherently resistant to phishing because there's no credential to hand over. The code is short-lived and tied to a specific email address.</p>
<p><strong>Passwords require just as much email verification.</strong> Here's the thing people overlook: even with passwords, you still need to verify the user's email. Otherwise anyone can create an account with someone else's email address. So you end up building the same email verification flow that login links use, plus the password management on top of it. You're not avoiding email. You're adding a password layer on top of it.</p>
<p><strong>The industry agrees.</strong> Look at what banks and other high-security sites do now: even after you enter your email and password, they send you a one-time code via text or email. Password alone isn't enough anymore, so they've added the exact same verification step we use. Some have a "remember this device for 2 weeks" checkbox, but in practice it rarely works. You log in an hour later after your session times out and they're sending you another code. It's not just frustrating. It reveals that the password itself has become a meaningless step. The one-time code is doing the actual authentication. The password is just theater you have to sit through before you get to the part that matters. We skip it entirely.</p>
<p><strong>Passwords add surface area.</strong> With passwords, you need: secure hashing (bcrypt/argon2), a "forgot password" flow (which is itself a login link), password strength validation, brute force protection on the login form, and secure storage. Login links need rate limiting and token management too, but the overall surface area is smaller. There's no credential to store long-term, no password policy to enforce, and no "forgot password" flow to build since the login flow <em>is</em> the recovery flow.</p>
<p><strong>"But what about password managers?"</strong> Password managers are great. They solve the reuse and phishing problems for users who use them. But most users don't. And for the curling club use case, where members log in a handful of times per season, asking them to set up and maintain a password manager is unrealistic. Login links meet users where they are.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-login-links-are-secure">How Login Links Are Secure<a href="https://curling.io/blog/passwordless-auth-done-right#how-login-links-are-secure" class="hash-link" aria-label="Direct link to How Login Links Are Secure" title="Direct link to How Login Links Are Secure">​</a></h2>
<p>A login link is a short-lived code sent to your email. The security model rests on a simple assumption: if you can read email sent to that address, you control that address. This is the same assumption that password reset flows rely on, but we cut out the middleman.</p>
<p>Here's what makes the implementation secure:</p>
<p><strong>High-entropy tokens.</strong> Each login code is drawn from a high-entropy space, but it doesn't need to be astronomical because of the next two points. The token generator uses Gleam's binary pattern matching to map cryptographically random bytes to an unambiguous alphabet:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn generate_token() -&gt; String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let alphabet_size = string.length(token_alphabet)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  crypto.strong_random_bytes(token_length)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  |&gt; pick_chars(alphabet_size, "")</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">fn pick_chars(bytes: BitArray, alphabet_size: Int, acc: String) -&gt; String {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  case bytes {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    &lt;&lt;b, rest:bits&gt;&gt; -&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      let idx = b % alphabet_size</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      let ch = string.slice(token_alphabet, idx, 1)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      pick_chars(rest, alphabet_size, acc &lt;&gt; ch)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    _ -&gt; acc</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>Aggressive rate limiting.</strong> Authentication attempts are tightly rate limited across multiple layered time windows. Brute-forcing the token space is completely impractical. Each window is checked in sequence using Gleam's <code>use</code> syntax. If any window is exceeded, it short-circuits and returns the retry-after time without checking the rest:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn check_verification_attempt(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  limiter: RateLimiter,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  email: String,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  now: Int,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">) -&gt; Result(Nil, Int) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let key = key_prefix &lt;&gt; string.lowercase(email)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  use _ &lt;- result.try(check(limiter, key, attempts_per_minute, 60, now))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  use _ &lt;- result.try(check(limiter, key, attempts_per_15_minutes, 900, now))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  use _ &lt;- result.try(check(limiter, key, attempts_per_hour, 3600, now))</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  check(limiter, key, attempts_per_day, 86_400, now)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<p><strong>Short-lived.</strong> Each code expires quickly. After verification, the token hash is cleared from the database. There's no window for replay attacks.</p>
<p><strong>Constant-time comparison.</strong> We look up the email row first, then compare the submitted token hash against the stored hash using Gleam's <code>crypto.secure_compare</code>. This takes the same amount of time regardless of where the first mismatch occurs, preventing timing attacks that could leak information about partial matches. If the current token doesn't match, we check the previous token, not to log them in, but to return a specific error message guiding the user to check for a more recent email:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let hashes_match =</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  crypto.secure_compare(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    bit_array.from_string(submitted_hash),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    bit_array.from_string(stored_hash),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">case hashes_match {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  True -&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case row.token_expires_at {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      Some(expires_at) if expires_at &gt; now -&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        complete_verification(conn, row, now)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      _ -&gt; Error(ExpiredToken)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  False -&gt;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    case row.previous_token_hash {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      Some(prev_hash) -&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        let prev_match =</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">          crypto.secure_compare(</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            bit_array.from_string(submitted_hash),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            bit_array.from_string(prev_hash),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">          )</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        case prev_match {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">          True -&gt; Error(SupersededToken)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">          False -&gt; Error(InvalidToken)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      None -&gt; Error(InvalidToken)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Every branch returns a specific error variant, and the compiler ensures we handle all of them. No forgotten edge cases. The previous token never grants access. It only exists to give a better error message than a generic "invalid token."</p>
<p><strong>No credential storage.</strong> There are no passwords in our database. In a breach scenario, attackers get token hashes that are short-lived. Compare that to a password database where every hash is a target for offline cracking.</p>
<p>It's also worth noting that the main vulnerability of login links is a compromised email account. But if someone's email is compromised, they have much bigger problems than their Curling IO profile. And a password-based system is equally vulnerable in that scenario. The attacker just clicks "forgot password" and they're in.</p>
<p>The bottom line: login links are not a weaker form of authentication. For our use case, they're stronger. They eliminate entire categories of attacks (credential stuffing, phishing, password spraying) while being simpler for both users and developers.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="takeaways-from-version-2">Takeaways from Version 2<a href="https://curling.io/blog/passwordless-auth-done-right#takeaways-from-version-2" class="hash-link" aria-label="Direct link to Takeaways from Version 2" title="Direct link to Takeaways from Version 2">​</a></h2>
<p>Version 2's login link flow is straightforward: enter your email, get a code, enter the code, you're in. It works. But after a decade and hundreds of thousands of users, a few pain points emerged.</p>
<p><strong>One email, one identity.</strong> In Version 2, your email <em>is</em> your identity. Log in with a different email, you get a different account. This has been a real source of confusion. A club manager registers with their work email, then tries to log in from their phone with their personal email, and they're looking at an empty account. We'd get support requests about "missing registrations" that were really just the same person with two accounts.</p>
<p><strong>Unhelpful error messages.</strong> This one came up a lot. A curler would request a login link, wait a minute or two, not see the email, and request another one. The first email was usually just delayed. Many email clients only check for new mail every 5 to 15 minutes. When the first email finally arrived and they clicked it, they'd get a generic "invalid token" error because the second request had replaced the first. They'd wonder if they mistyped something, try again, get confused, and contact support.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="version-3-adds-multiple-email-addresses">Version 3 Adds Multiple Email Addresses<a href="https://curling.io/blog/passwordless-auth-done-right#version-3-adds-multiple-email-addresses" class="hash-link" aria-label="Direct link to Version 3 Adds Multiple Email Addresses" title="Direct link to Version 3 Adds Multiple Email Addresses">​</a></h2>
<p>This is the big addition. Users can now associate multiple verified email addresses with their account:</p>
<p><strong>Add an email.</strong> From the account page, enter a new email address. We send a verification code using the same mechanism as login.</p>
<p><strong>Verify it.</strong> Enter the code. The email is now linked to your account and marked as verified. Unverified emails can't be used for anything.</p>
<p><strong>Set it as primary.</strong> Any verified email can be promoted to primary. Your primary email is what shows up across the platform, in admin dashboards, on team rosters, in email communications. Changing your primary is a single click.</p>
<p><strong>Remove it.</strong> Non-primary emails can be removed. You can't remove your primary (switch to a different one first) and you can't remove your last verified email (you need at least one to log in).</p>
<p><strong>Log in with any of them.</strong> This is the key benefit. Once you've added and verified multiple emails, logging in with <em>any</em> of them resolves to the same account, the same registrations, the same history. No more duplicate accounts because you used a different email.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-it-works-under-the-hood">How It Works Under the Hood<a href="https://curling.io/blog/passwordless-auth-done-right#how-it-works-under-the-hood" class="hash-link" aria-label="Direct link to How It Works Under the Hood" title="Direct link to How It Works Under the Hood">​</a></h3>
<p>Each email row tracks a few key fields:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">email               -- globally unique, one owner max</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">user_id             -- nullable; not set until verified for first-time logins</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">token_hash          -- pending verification token</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">previous_token_hash -- the token that was replaced (for superseded detection)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">verified_at         -- null until verified</span><br></span></code></pre></div></div>
<p>This single structure handles both login verification and email ownership.</p>
<p>The design means multi-email support was almost free. The same verification flow used for login handles email verification for logged-in users. The only difference is that the user is already set when you're adding an email to your existing account.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="superseded-token-detection">Superseded Token Detection<a href="https://curling.io/blog/passwordless-auth-done-right#superseded-token-detection" class="hash-link" aria-label="Direct link to Superseded Token Detection" title="Direct link to Superseded Token Detection">​</a></h2>
<p>Remember the delayed email problem from Version 2? A curler requests a link, doesn't see it right away, requests another, and then clicks the first one when it finally arrives. Version 3 handles this gracefully.</p>
<p>When a new login link is requested, we don't just overwrite the old token. We move the current <code>token_hash</code> to <code>previous_token_hash</code> first. If someone then tries the old token, we can tell the difference:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub type AuthError {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  InvalidToken      // not found or already used</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  SupersededToken   // replaced by a newer token</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  ExpiredToken      // past expiry</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  UserDisabled      // account disabled</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  DatabaseError(sqlight.Error)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>A <code>SupersededToken</code> gets a specific message: "This code has been replaced. Check for a more recent email or request a new link." Instead of leaving users confused, we point them in the right direction.</p>
<p>This is a pattern we use throughout Version 3. Gleam's union types let us model every possible error state explicitly, and the compiler ensures we handle all of them. No forgotten edge cases, no generic catch-all error messages.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="oauth-google-and-facebook">OAuth (Google and Facebook)<a href="https://curling.io/blog/passwordless-auth-done-right#oauth-google-and-facebook" class="hash-link" aria-label="Direct link to OAuth (Google and Facebook)" title="Direct link to OAuth (Google and Facebook)">​</a></h2>
<p>Login links aren't the only way in. Google and Facebook login work alongside them for users who prefer one-click SSO.</p>
<p>The OAuth flow uses a central auth subdomain (<code>auth.curling.io</code>) to handle callbacks, since both providers require a fixed redirect URI. After the provider verifies the user's identity, we look up the email in the same table used for login links. If the email exists with a user, log them in. If not, create the user and a verified email row (OAuth emails are pre-verified by the provider).</p>
<p>The same user resolution logic, regardless of how you authenticate.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="a-note-on-rolling-your-own-auth">A Note on Rolling Your Own Auth<a href="https://curling.io/blog/passwordless-auth-done-right#a-note-on-rolling-your-own-auth" class="hash-link" aria-label="Direct link to A Note on Rolling Your Own Auth" title="Direct link to A Note on Rolling Your Own Auth">​</a></h2>
<p>Writing your own authentication is generally a bad idea. Battle-tested libraries like <a href="https://github.com/heartcombo/devise" target="_blank">Devise</a> (Ruby), <a href="https://next-auth.js.org/" target="_blank">NextAuth</a> (JavaScript), and <a href="https://django-allauth.readthedocs.io/" target="_blank">django-allauth</a> (Python) exist for good reason. They've been hardened over years of real-world use and security audits. If you're building on a stack that has a mature auth library, use it.</p>
<p>We couldn't find an existing Gleam auth library that was the right fit for our specific needs, but we didn't design in a vacuum. We studied Devise's modules extensively (Lockable, Timeoutable, Trackable, Confirmable) and used them as a checklist for what a production auth system needs to handle. Every security decision we made, from constant-time comparison to layered rate limiting to email enumeration prevention, was informed by what these libraries have learned the hard way over the past decade.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="whats-next">What's Next<a href="https://curling.io/blog/passwordless-auth-done-right#whats-next" class="hash-link" aria-label="Direct link to What's Next" title="Direct link to What's Next">​</a></h2>
<p>Authentication is foundational, but the real value of multi-email support shows up when it connects to everything else: registrations, team management, admin permissions, payment history. As we build those features, having clean user resolution across multiple emails will simplify a lot of workflows that were painful in Version 2.</p>
<p>We're also considering optional two-factor authentication for club administrators, via authenticator apps or SMS, for organizations that want to force an extra layer of security on accounts with administrative access.</p>
<hr>
<p><em>This is Part 3 of the Curling IO Foundation series. Next up: background jobs on the BEAM, with no Redis, no separate worker, and no additional infrastructure.</em></p>]]></content>
        <author>
            <name>Dave Rapin</name>
        </author>
        <category label="foundation" term="foundation"/>
        <category label="authentication" term="authentication"/>
        <category label="gleam" term="gleam"/>
        <category label="security" term="security"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Bilingual by Design]]></title>
        <id>https://curling.io/blog/bilingual-by-design</id>
        <link href="https://curling.io/blog/bilingual-by-design"/>
        <updated>2026-02-15T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Curling IO serves hundreds of clubs across Canada, where English and French aren't optional, they're official languages. A club in Quebec needs a fully French experience. A national organization like Curling Canada needs both. Rails has mature i18n support and Version 2 has been fully bilingual from the start, but after a decade of maintaining around 10,000 YAML translation keys, we've hit the limits of what that approach can catch: missing keys, missing translations, and unused keys that accumulate silently over time.]]></summary>
        <content type="html"><![CDATA[<p>Curling IO serves hundreds of clubs across Canada, where English and French aren't optional, they're official languages. A club in Quebec needs a fully French experience. A national organization like Curling Canada needs both. Rails has mature i18n support and Version 2 has been fully bilingual from the start, but after a decade of maintaining around 10,000 YAML translation keys, we've hit the limits of what that approach can catch: missing keys, missing translations, and unused keys that accumulate silently over time.</p>
<p>In Version 3, we wanted compile-time guarantees that make those problems impossible. This post covers how we designed the i18n system, why we split it into two layers, and what we changed from Version 2.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="two-kinds-of-text-two-different-systems">Two Kinds of Text, Two Different Systems<a href="https://curling.io/blog/bilingual-by-design#two-kinds-of-text-two-different-systems" class="hash-link" aria-label="Direct link to Two Kinds of Text, Two Different Systems" title="Direct link to Two Kinds of Text, Two Different Systems">​</a></h2>
<p>Every bilingual web application has two fundamentally different kinds of text:</p>
<ol>
<li><strong>App labels</strong>: static UI strings like "Leagues", "Contact", "Email". These are written by developers and change at deploy time.</li>
<li><strong>Content</strong>: user-entered data like league names, summaries, and descriptions. These are entered by club managers and may change at any time.</li>
</ol>
<table><thead><tr><th></th><th>App Labels</th><th>Content</th></tr></thead><tbody><tr><td><strong>Who writes it</strong></td><td>Developers</td><td>Club managers</td></tr><tr><td><strong>When it changes</strong></td><td>At deploy time</td><td>At any time</td></tr><tr><td><strong>Where it lives</strong></td><td>Compiled code</td><td>Database</td></tr><tr><td><strong>Scope</strong></td><td>Global (all clubs)</td><td>Per-record</td></tr></tbody></table>
<p>In Version 2, app labels came from Rails i18n YAML files loaded at boot, and content was stored in per-language database columns (<code>name_en</code>, <code>name_fr</code>, <code>summary_en</code>, <code>summary_fr</code>). This worked, but had pain points we wanted to address.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-version-2-taught-us">What Version 2 Taught Us<a href="https://curling.io/blog/bilingual-by-design#what-version-2-taught-us" class="hash-link" aria-label="Direct link to What Version 2 Taught Us" title="Direct link to What Version 2 Taught Us">​</a></h2>
<p><strong>The YAML files grew unwieldy.</strong> Over the years, our <code>en.yml</code> and <code>fr.yml</code> files accumulated thousands of keys each. Finding unused keys was a manual process. Ensuring every English key had a French counterpart required discipline that occasionally slipped, resulting in untranslated UI elements showing up in production as blank strings or key paths like <code>en.registrations.confirm_button</code>.</p>
<p><strong>Per-language columns didn't scale.</strong> The <code>leagues</code> table in Version 2 has <code>name_en</code>, <code>name_fr</code>, <code>summary_en</code>, <code>summary_fr</code>, <code>description_en</code>, <code>description_fr</code>, <code>post_registration_message_en</code>, <code>post_registration_message_fr</code>, <code>required_reading_en</code>, <code>required_reading_fr</code>. That's 10 columns just for translated text on one table. Every new translatable field requires a migration adding two columns. If we ever added a third language, it would mean another column for every translatable field on every table.</p>
<p><strong>Blank vs. missing was ambiguous.</strong> When <code>name_fr</code> was empty, did the manager intentionally leave it blank, or did they just not get around to translating it? The system couldn't tell the difference.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="version-3-app-label-translations">Version 3: App Label Translations<a href="https://curling.io/blog/bilingual-by-design#version-3-app-label-translations" class="hash-link" aria-label="Direct link to Version 3: App Label Translations" title="Direct link to Version 3: App Label Translations">​</a></h2>
<p>App labels are compiled directly into the application. No database, no YAML files, no runtime file loading. Just Gleam code.</p>
<p>The structure is simple:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">translations/keys.gleam   constants for every key</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">translations/en.gleam     English values</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">translations/fr.gleam     French values</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">translations.gleam        builds the lookup, provides t()</span><br></span></code></pre></div></div>
<p><strong>Key constants</strong> are <code>pub const</code> values in <code>keys.gleam</code>. This is extra code we've added specifically to get compile-time correctness. Every key used in a page or language file references these constants, so a misspelled key is a compile error rather than a silent runtime bug:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub const leagues = "leagues"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub const contact = "contact"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub const email_label = "email_label"</span><br></span></code></pre></div></div>
<p>Notice these are flat, no nesting. In Version 2, Rails i18n keys were nested by namespace (<code>en.registrations.confirm_button</code>, <code>en.leagues.index.title</code>, etc.). In practice, the nesting added complexity without much benefit: keys were harder to grep for, reorganizing namespaces meant touching multiple files, and deeply nested YAML was error-prone to edit. Flat keys are simpler to search, simpler to maintain, and work just as well with thousands of entries.</p>
<p><strong>Language files</strong> map those constants to translated values:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// en.gleam</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.leagues, "Leagues"),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.contact, "Contact"),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.email_label, "Email"),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// fr.gleam</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.leagues, "Ligues"),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.contact, "Contact"),</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">#(k.email_label, "Courriel"),</span><br></span></code></pre></div></div>
<p>At startup, <code>translations.build()</code> assembles these into a nested dictionary (outer key is language code, inner key is translation key). This dictionary gets stored in the application context and threaded into every request. Lookup is two hash table reads, effectively instant.</p>
<p><strong>In pages</strong>, we partial-apply the lookup function for the current language:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">let t = t.t(rc.translations, rc.lang, _)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Then just call t() with key constants</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">element.text(t(k.leagues))   // "Leagues" or "Ligues"</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">element.text(t(k.contact))  // "Contact" (same in both languages!)</span><br></span></code></pre></div></div>
<p>This is clean, type-safe, and impossible to mess up at runtime. If a key is missing from a language file, the UI shows <code>"[missing: postal_code_label]"</code> so it's immediately clear something needs to be fixed. Much better than a silent blank.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="catching-problems-at-compile-and-test-time">Catching Problems at Compile and Test Time<a href="https://curling.io/blog/bilingual-by-design#catching-problems-at-compile-and-test-time" class="hash-link" aria-label="Direct link to Catching Problems at Compile and Test Time" title="Direct link to Catching Problems at Compile and Test Time">​</a></h3>
<p>Using constants instead of raw strings means a typo like <code>t(k.legues)</code> is a compile error because the constant doesn't exist. That alone eliminates an entire class of bugs we dealt with in Version 2.</p>
<p>We also have a test that verifies every English key has a French counterpart and vice versa:</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">pub fn should_have_same_keys_in_en_and_fr_test() {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let en_keys = en.all() |&gt; dict.keys() |&gt; set.from_list()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  let fr_keys = fr.all() |&gt; dict.keys() |&gt; set.from_list()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  set.difference(en_keys, fr_keys) |&gt; should.equal(set.new())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  set.difference(fr_keys, en_keys) |&gt; should.equal(set.new())</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<p>Adding a key to English without adding it to French fails the test suite. No more discovering untranslated strings in production.</p>
<p>We also have a script that checks for keys defined but never actually used in any page or template (dead key detection). Between the compiler, the parity test, and the unused key checker, translation problems are caught long before they reach users.</p>
<p>Notice how small the test surface is. Because Gleam's type system handles so much at compile time, our tests focus on validating design decisions and business logic rather than guarding against runtime surprises. In Version 2 with Rails, a lot of test effort goes toward catching things that a type system would prevent: nil values, wrong argument types, missing method calls. In Gleam, the compiler handles all of that, so our translation tests are purely about the logic we actually care about: do all languages have the same keys? Does the fallback behavior work correctly?</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="version-3-content-translations">Version 3: Content Translations<a href="https://curling.io/blog/bilingual-by-design#version-3-content-translations" class="hash-link" aria-label="Direct link to Version 3: Content Translations" title="Direct link to Version 3: Content Translations">​</a></h2>
<p>Content translations (the user-entered data) take a different approach. Instead of per-language columns, each translatable table has a single <code>translations</code> JSON column:</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token property">"fr"</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token property">"name"</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">"Ligue du lundi"</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token property">"summary"</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> </span><span class="token string" style="color:rgb(195, 232, 141)">"Résumé en français"</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><br></span></code></pre></div></div>
<p>The primary language value lives in the regular column (<code>name</code>, <code>summary</code>). Only secondary language overrides go in the JSON. This means:</p>
<ul>
<li><strong>Primary language reads are free.</strong> No JSON parsing needed, just read the column.</li>
<li><strong>No translations? No overhead.</strong> The column is <code>NULL</code>.</li>
<li><strong>Adding translatable fields requires zero schema changes.</strong> Just start putting the field name in the JSON.</li>
<li><strong>Adding a third language is just another key in the JSON.</strong> No migration needed.</li>
</ul>
<p>The resolution logic is straightforward: if the user is viewing in the primary language, return the regular column. If they're viewing in a secondary language, look it up in the JSON. If it's not there, fall back to the primary language value. Every field degrades gracefully. A missing French translation shows the English text rather than nothing.</p>
<div class="language-gleam codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-gleam codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Parse once per record</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let parsed = i18n.parse(league.data.translations)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Resolve each field for the current language</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">let name = i18n.resolve(league.data.name, parsed, lang, primary_lang, "name")</span><br></span></code></pre></div></div>
<p>This solves the blank-vs-missing ambiguity from Version 2: if a field isn't in the <code>translations</code> JSON, it simply hasn't been translated yet, and the primary language value is shown. No guessing.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="language-routing">Language Routing<a href="https://curling.io/blog/bilingual-by-design#language-routing" class="hash-link" aria-label="Direct link to Language Routing" title="Direct link to Language Routing">​</a></h2>
<p>Language selection comes from the URL path, not cookies or browser headers. This keeps things deterministic and shareable. A French URL always shows French content:</p>
<ul>
<li><code>/leagues</code> - primary language (no prefix)</li>
<li><code>/fr/leagues</code> - French (secondary language prefix)</li>
<li><code>/en/leagues</code> - redirects to <code>/leagues</code> (primary language never gets a prefix)</li>
</ul>
<p>The router extracts the language from the first path segment, stores it in the request context, and every page and API handler downstream uses it. Clean, predictable, and great for SEO.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="whats-next">What's Next<a href="https://curling.io/blog/bilingual-by-design#whats-next" class="hash-link" aria-label="Direct link to What's Next" title="Direct link to What's Next">​</a></h2>
<p>The i18n foundation is in place. As we build out more features (admin interfaces, registration flows, email notifications) we'll add keys to the app label system and the <code>translations</code> JSON column to more tables. The system is designed to scale to thousands of keys without any architectural changes.</p>
<hr>
<p><em>This is Part 2 of the Curling IO Foundation series. Next up: <a href="https://curling.io/blog/passwordless-auth-done-right">passwordless authentication and multi-email support</a>.</em></p>]]></content>
        <author>
            <name>Dave Rapin</name>
        </author>
        <category label="foundation" term="foundation"/>
        <category label="i18n" term="i18n"/>
        <category label="gleam" term="gleam"/>
        <category label="architecture" term="architecture"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[The Next Version of Curling IO]]></title>
        <id>https://curling.io/blog/the-next-version-of-curling-io</id>
        <link href="https://curling.io/blog/the-next-version-of-curling-io"/>
        <updated>2026-02-12T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We're building the next version of Curling IO - same features, same experience, stronger foundation. After over a decade of serving hundreds of curling organizations across Canada, the US, and internationally, we're investing in technical upgrades that set Curling IO up for the next 20+ years.]]></summary>
        <content type="html"><![CDATA[<p>We're building the next version of Curling IO - same features, same experience, stronger foundation. After over a decade of serving hundreds of curling organizations across Canada, the US, and internationally, we're investing in technical upgrades that set Curling IO up for the next 20+ years.</p>
<p>This is Part 1 of a series of technical posts documenting our journey and decisions as we build.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="how-this-affects-you">How This Affects You<a href="https://curling.io/blog/the-next-version-of-curling-io#how-this-affects-you" class="hash-link" aria-label="Direct link to How This Affects You" title="Direct link to How This Affects You">​</a></h2>
<p><strong>For club managers:</strong> Curling IO isn't changing from your perspective. We're upgrading the technical infrastructure behind the scenes - no downtime, no disruption, no action required from you. Your data stays exactly where it is. When the upgrade is complete (thoroughly tested and proven), the transition will be seamless. You'll have the same Curling IO you know, even faster and more reliable.</p>
<p><strong>For curlers:</strong> You won't notice the technology change. Registration, scoring, schedules, results - everything works the same way. You might notice things feel snappier, especially during peak registration times or when checking live scores at major competitions.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="why-a-new-foundation">Why a New Foundation?<a href="https://curling.io/blog/the-next-version-of-curling-io#why-a-new-foundation" class="hash-link" aria-label="Direct link to Why a New Foundation?" title="Direct link to Why a New Foundation?">​</a></h2>
<p>Curling IO has been serving curling clubs since late 2014. We upgraded the platform once already in 2019, and our Version 2 system has been running successfully on Rails ever since. Everything works, clubs are happy, and growth is strong. So why invest in a new foundation?</p>
<p>Because we're planning to be here for the long haul. This new foundation ensures Curling IO can serve curling clubs not just for the next few years, but for the next 20+ years. While competitors come and go, we're investing in infrastructure built to last and evolve with the sport.</p>
<p><strong>Three key reasons:</strong></p>
<ol>
<li>
<p><strong>AI Agent APIs</strong> - We're adding new APIs specifically designed for AI agents to work with easily. Your existing web interface isn't changing - these are additional capabilities on top of what you already use. As AI assistants become ubiquitous (whether you love them or not), we're designing for that reality. Users are already asking ChatGPT and Claude to help them register for leagues or check schedules - we want those interactions to work reliably.</p>
</li>
<li>
<p><strong>Concurrency and correctness</strong> - As the platform grows, we need stronger guarantees around correctness and performance. We want a tech stack that can handle massive concurrency - both during peak registration periods and during large traffic spikes for scoring and results at provincial and national competitions like the Scotties and Brier. It needs to prevent runtime errors and scale efficiently as the sport grows.</p>
</li>
<li>
<p><strong>Easier developer onboarding</strong> - We want a codebase that's easy to hand off between developers. Type safety and functional patterns make code self-documenting - new developers (with help from AI coding assistants) can jump in and contribute safely without deep institutional knowledge. Gleam's deterministic patterns are much easier for AI assistants to reason about than dynamic languages, which means faster onboarding and more productive collaboration between developers and their AI tools. This significantly reduces key-person dependency.</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="choosing-the-tech-stack">Choosing the Tech Stack<a href="https://curling.io/blog/the-next-version-of-curling-io#choosing-the-tech-stack" class="hash-link" aria-label="Direct link to Choosing the Tech Stack" title="Direct link to Choosing the Tech Stack">​</a></h2>
<p>Given our goals - agent-native APIs, clean architecture, and battle-tested reliability at scale - we need a stack that can deliver:</p>
<p><strong>What we're looking for</strong></p>
<ul>
<li><strong>Type safety</strong> - Catch errors at compile time, not in production</li>
<li><strong>Massive concurrency</strong> - Handle thousands of simultaneous registrations</li>
<li><strong>Functional patterns</strong> - Predictable, testable code that developers can reason about</li>
<li><strong>Shared types</strong> - Same data structures on client and server</li>
<li><strong>Proven at scale</strong> - Used in production by major companies</li>
</ul>
<p><strong>Why Gleam?</strong></p>
<p><a href="https://gleam.run/" target="_blank">Gleam</a> checks every box. It's a type-safe functional language that compiles to both Erlang (for the server) and JavaScript (for the client). You get:</p>
<ul>
<li><strong><a href="https://www.erlang.org/blog/a-brief-beam-primer/" target="_blank">BEAM VM</a> reliability</strong> - The same runtime that powers WhatsApp (billions of messages with ~50 engineers) and Discord (millions of concurrent users). Built-in fault tolerance and lightweight processes.</li>
<li><strong>ML-family type system</strong> - Stronger than Elixir, catches entire classes of bugs at compile time</li>
<li><strong><a href="https://lustre.build/" target="_blank">Lustre</a> for frontend</strong> - An <a href="https://elm-lang.org/" target="_blank">Elm</a>-architecture framework for Gleam that compiles to JavaScript. We already love Elm for our current frontend apps, and Lustre brings that same architecture everywhere. Same types from database to UI, all type-safe.</li>
<li><strong>Simple language</strong> - Focused, consistent, easy to reason about. Perfect for building deterministic APIs.</li>
</ul>
<p><strong>What about other options?</strong></p>
<p>We didn't jump straight to Gleam. We seriously considered several other stacks:</p>
<p><strong><a href="https://postgrest.org/" target="_blank">PostgREST</a> + Elm/Lustre</strong> - This was a very serious contender using tools we're already familiar with. PostgREST provides instant APIs from your PostgreSQL schema, and Elm/Lustre provides type-safe UI. But we'd need something else for background jobs (like Go), and the tooling for building, debugging, and testing PostgreSQL functions isn't great. The multi-language setup felt fragmented.</p>
<p><strong><a href="https://safe-stack.github.io/" target="_blank">F# SAFE Stack</a></strong> - F# is a fantastic functional language with a solid .NET ecosystem. The SAFE stack (Suave/Saturn, Azure/AWS, Fable, Elmish) offers full-stack type safety with The Elm Architecture (TEA) on the frontend. We really liked this option, but ultimately chose Gleam for its BEAM VM benefits and simpler deployment story.</p>
<p><strong>TypeScript + Node + React</strong> - The obvious choice given its massive ecosystem and the sheer volume of material AI agents can draw from. We've been using React off and on since 2014 and like Redux (which is Elm-inspired) for the frontend. But JavaScript/TypeScript has issues we couldn't get past: nulls everywhere, a type system that feels bolted on (TypeScript's safety is opt-out with <code>any</code>, <code>as</code>, and <code>!</code>), relentless library churn, and recurring npm supply chain vulnerabilities. React itself has become overly complex. Popularity is a real advantage, but it wasn't enough to outweigh the correctness and simplicity we wanted.</p>
<p><strong>BEAM was the killer feature.</strong> None of these other options came close to what the BEAM VM offers: rock-solid concurrency, fault tolerance, and proven scalability (WhatsApp, Discord, etc.). Gleam gives us BEAM on the backend with familiar functional patterns (like Elm) on the frontend, all in a single language.</p>
<p><strong>Why not stick with Rails?</strong></p>
<p>To be clear: we love <a href="https://rubyonrails.org/" target="_blank">Ruby on Rails</a>. It's been amazing for rapid development and has scaled well for our needs. For heavier interactive features, we've already been using Elm for frontend apps like Bracket Builder, Scheduling, Scoring, and Results widgets, with PostgREST providing clean APIs on the backend. This functional programming approach has worked really well.</p>
<p>But for where we're headed, we need:</p>
<ul>
<li>Compile-time safety (Ruby is dynamically typed)</li>
<li>BEAM-level concurrency (Rails doesn't even come close)</li>
<li>Shared client/server types (Rails is backend-only)</li>
<li>Functional patterns built-in (Rails is object-oriented)</li>
</ul>
<p>This isn't about Rails being bad - we've been building with it since version 1.2 and nothing else lets you iterate that fast. But over time we've moved towards functional, compiled, typed languages because runtime errors are the absolute worst to debug and fix. Gleam gives us that correctness without giving up the developer experience we love about Rails.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="sqlite-over-postgresql">SQLite Over PostgreSQL<a href="https://curling.io/blog/the-next-version-of-curling-io#sqlite-over-postgresql" class="hash-link" aria-label="Direct link to SQLite Over PostgreSQL" title="Direct link to SQLite Over PostgreSQL">​</a></h2>
<p><strong>This one surprised us.</strong></p>
<p>Curling IO Version 2 runs on PostgreSQL. We assumed we'd use Postgres for Version 3. But we're betting on <a href="https://sqlite.org/" target="_blank">SQLite</a> instead.</p>
<p><strong>Why SQLite?</strong></p>
<ul>
<li><strong>Isolated databases</strong> - Clean separation of concerns with dedicated database files</li>
<li><strong>In-process speed</strong> - Zero network latency between app and database</li>
<li><strong>Operational simplicity</strong> - No database server to manage, tune, or cluster</li>
<li><strong>Cost savings</strong> - Orders of magnitude cheaper than <a href="https://www.crunchydata.com/products/crunchy-bridge" target="_blank">managed Postgres</a></li>
<li><strong><a href="https://litestream.io/" target="_blank">Litestream</a> backups</strong> - Continuous replication to offsite storage</li>
</ul>
<p><strong>What about scale?</strong></p>
<p>For the same infrastructure budget as Rails + PostgreSQL, we expect Gleam + SQLite to handle roughly:</p>
<ul>
<li>1,000x more concurrent connections</li>
<li>100x the data volume</li>
<li>100x the throughput during peak traffic (registrations, live scoring)</li>
</ul>
<p>These numbers sound outrageous, but they aren't pulled out of thin air. BEAM processes are ~2KB each vs Rails threads at ~1MB - that's where the 1,000x connection multiplier comes from. And eliminating network round-trips to a separate database server (SQLite runs in-process) while leveraging BEAM's lightweight concurrency model accounts for the throughput gains. These are well-documented characteristics of the technology, not optimistic guesses.</p>
<p>That said, we'll be validating everything with extensive benchmarking and real-world load tests as we build.</p>
<p>If SQLite doesn't scale as expected, we'll just stick with PostgreSQL - an equally great database.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="vertical-first-scaling">Vertical-First Scaling<a href="https://curling.io/blog/the-next-version-of-curling-io#vertical-first-scaling" class="hash-link" aria-label="Direct link to Vertical-First Scaling" title="Direct link to Vertical-First Scaling">​</a></h2>
<p>Our scaling strategy is simple: start on a single powerful server and scale up from there.</p>
<ul>
<li>One server with co-located app + database (one thing to deploy, backup, monitor)</li>
<li>Warm backup server + continuous offsite backups</li>
<li>Scale up CPU and RAM as we grow</li>
<li>No distributed systems complexity until actually needed</li>
</ul>
<p>If we ever outgrow a single server, we have a clean path to splitting things up. But with BEAM's concurrency and SQLite's in-process speed, we expect that to be a long way off.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="whats-next">What's Next<a href="https://curling.io/blog/the-next-version-of-curling-io#whats-next" class="hash-link" aria-label="Direct link to What's Next" title="Direct link to What's Next">​</a></h2>
<p>We'll be building this out over the coming months alongside the existing platform. Curling IO Version 2 isn't going anywhere - it continues to run and receive updates as usual. When Version 3 is ready and thoroughly tested, we'll transition everyone over at once - a clean, coordinated switch rather than a drawn-out process. We won't make that switch until we're confident everything is solid.</p>
<hr>
<p><em>This is Part 1 of the Curling IO Foundation series. Next up: <a href="https://curling.io/blog/bilingual-by-design">bilingual support with compile-time guarantees</a>.</em></p>]]></content>
        <author>
            <name>Dave Rapin</name>
        </author>
        <category label="foundation" term="foundation"/>
        <category label="architecture" term="architecture"/>
        <category label="gleam" term="gleam"/>
        <category label="sqlite" term="sqlite"/>
        <category label="scaling" term="scaling"/>
    </entry>
</feed>